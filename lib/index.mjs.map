{"version":3,"sources":["../src/hashi-vault.ts"],"sourcesContent":["import { contentTypes, create_instance, methods } from \"fetcher\";\nimport { VaultClientConfig } from \"./types/vault-client-config\";\nimport { GetSecretParams } from \"./types/get-secret-params\";\nimport { CreateSecretParams } from \"./types/create-secret-params\";\n// import { logging } from \"./decorators/logging.decorator\";\n\nexport class HashiVault {\n  private fetcher: ReturnType<typeof create_instance>;\n  private rootPath?: string;\n  private appRole: string;\n  private roleId: string;\n  private secretId: string;\n  private clientToken: string | null = null;\n  private tokenExpiration: number | null = null;\n  private logging: boolean;\n\n  /**\n   * @param {VaultClientConfig} config - Configuration object for HashiVault\n   */\n  constructor({\n    baseURL,\n    rootPath,\n    appRole,\n    roleId,\n    secretId,\n    logging = false,\n  }: VaultClientConfig) {\n    this.fetcher = create_instance({\n      baseURL,\n      logging: logging,\n    });\n\n    if (rootPath) {\n      this.rootPath = rootPath;\n    }\n    this.appRole = appRole;\n    this.roleId = roleId;\n    this.secretId = secretId;\n    this.logging = logging;\n  }\n\n  /**\n   * Perform a health check on the Vault server\n   * @returns {Promise<any>} - Response data from the health check\n   */\n  //   @logging(true)\n  async healthCheck(): Promise<any> {\n    const response = await this.fetcher({\n      method: methods.get,\n      url: \"/sys/health\",\n      contentType: contentTypes.json,\n    });\n\n    return response.data;\n  }\n\n  /**\n   * Authenticate with AppRole to get a new client token\n   * @returns {Promise<void>}\n   */\n  private async authenticate(): Promise<void> {\n    const response = await this.fetcher({\n      method: methods.post,\n      url: `/auth/${this.appRole}/login`,\n      contentType: contentTypes.json,\n      body: {\n        role_id: this.roleId,\n        secret_id: this.secretId,\n      },\n    });\n\n    const data = response.data;\n    this.clientToken = data.auth.client_token;\n    this.tokenExpiration = Date.now() + data.auth.lease_duration * 1000; // Convert seconds to milliseconds\n  }\n\n  /**\n   * Get the current token, refreshing it if necessary\n   */\n  private async getToken(): Promise<string> {\n    if (\n      !this.clientToken ||\n      (this.tokenExpiration && Date.now() >= this.tokenExpiration)\n    ) {\n      await this.authenticate();\n    }\n    return this.clientToken!;\n  }\n\n  /**\n   * Get a secret from Vault\n   * @param {GetSecretParams} params - Parameters for getting a secret\n   * @returns {Promise<any>} - Secret data\n   */\n  async getSecret({ rootPath, path }: GetSecretParams): Promise<any> {\n    const token = await this.getToken();\n    const response = await this.fetcher({\n      method: methods.get,\n      url: `/${rootPath || this.rootPath}/data/${path}`,\n      contentType: contentTypes.json,\n      headers: {\n        \"X-Vault-Token\": token,\n      },\n    });\n\n    return response.data;\n  }\n\n  /**\n   * Create or update a secret in Vault\n   * @param {CreateSecretParams} params - Parameters for creating or updating a secret\n   * @returns {Promise<any>} - Response data from the Vault server\n   */\n  async createSecret({\n    rootPath,\n    path,\n    data,\n  }: CreateSecretParams): Promise<any> {\n    const token = await this.getToken();\n    const response = await this.fetcher({\n      method: methods.post,\n      url: `/${rootPath || this.rootPath}/data/${path}`,\n      contentType: contentTypes.json,\n      headers: {\n        \"X-Vault-Token\": token,\n      },\n      body: { data },\n    });\n\n    return response.data;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,cAAc,iBAAiB,eAAe;AAMhD,IAAM,aAAN,MAAiB;AAAA;AAAA;AAAA;AAAA,EAatB,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU;AAAA,EACZ,GAAsB;AAdtB,SAAQ,cAA6B;AACrC,SAAQ,kBAAiC;AAcvC,SAAK,UAAU,gBAAgB;AAAA,MAC7B;AAAA,MACA;AAAA,IACF,CAAC;AAED,QAAI,UAAU;AACZ,WAAK,WAAW;AAAA,IAClB;AACA,SAAK,UAAU;AACf,SAAK,SAAS;AACd,SAAK,WAAW;AAChB,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOM,cAA4B;AAAA;AAChC,YAAM,WAAW,MAAM,KAAK,QAAQ;AAAA,QAClC,QAAQ,QAAQ;AAAA,QAChB,KAAK;AAAA,QACL,aAAa,aAAa;AAAA,MAC5B,CAAC;AAED,aAAO,SAAS;AAAA,IAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMc,eAA8B;AAAA;AAC1C,YAAM,WAAW,MAAM,KAAK,QAAQ;AAAA,QAClC,QAAQ,QAAQ;AAAA,QAChB,KAAK,SAAS,KAAK,OAAO;AAAA,QAC1B,aAAa,aAAa;AAAA,QAC1B,MAAM;AAAA,UACJ,SAAS,KAAK;AAAA,UACd,WAAW,KAAK;AAAA,QAClB;AAAA,MACF,CAAC;AAED,YAAM,OAAO,SAAS;AACtB,WAAK,cAAc,KAAK,KAAK;AAC7B,WAAK,kBAAkB,KAAK,IAAI,IAAI,KAAK,KAAK,iBAAiB;AAAA,IACjE;AAAA;AAAA;AAAA;AAAA;AAAA,EAKc,WAA4B;AAAA;AACxC,UACE,CAAC,KAAK,eACL,KAAK,mBAAmB,KAAK,IAAI,KAAK,KAAK,iBAC5C;AACA,cAAM,KAAK,aAAa;AAAA,MAC1B;AACA,aAAO,KAAK;AAAA,IACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOM,UAAU,IAAmD;AAAA,+CAAnD,EAAE,UAAU,KAAK,GAAkC;AACjE,YAAM,QAAQ,MAAM,KAAK,SAAS;AAClC,YAAM,WAAW,MAAM,KAAK,QAAQ;AAAA,QAClC,QAAQ,QAAQ;AAAA,QAChB,KAAK,IAAI,YAAY,KAAK,QAAQ,SAAS,IAAI;AAAA,QAC/C,aAAa,aAAa;AAAA,QAC1B,SAAS;AAAA,UACP,iBAAiB;AAAA,QACnB;AAAA,MACF,CAAC;AAED,aAAO,SAAS;AAAA,IAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOM,aAAa,IAIkB;AAAA,+CAJlB;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,IACF,GAAqC;AACnC,YAAM,QAAQ,MAAM,KAAK,SAAS;AAClC,YAAM,WAAW,MAAM,KAAK,QAAQ;AAAA,QAClC,QAAQ,QAAQ;AAAA,QAChB,KAAK,IAAI,YAAY,KAAK,QAAQ,SAAS,IAAI;AAAA,QAC/C,aAAa,aAAa;AAAA,QAC1B,SAAS;AAAA,UACP,iBAAiB;AAAA,QACnB;AAAA,QACA,MAAM,EAAE,KAAK;AAAA,MACf,CAAC;AAED,aAAO,SAAS;AAAA,IAClB;AAAA;AACF;","names":[]}